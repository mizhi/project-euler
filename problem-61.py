#!/usr/bin/env python
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
# numbers are all figurate (polygonal) numbers and are generated by
# the following formulae:
#
# Triangle   P3,n=n(n+1)/2   1, 3, 6, 10, 15, ...
# Square   P4,n=n2   1, 4, 9, 16, 25, ...
# Pentagonal   P5,n=n(3n-1)/2   1, 5, 12, 22, 35, ...
# Hexagonal   P6,n=n(2n-1)   1, 6, 15, 28, 45, ...
# Heptagonal   P7,n=n(5n-3)/2   1, 7, 18, 34, 55, ...
# Octagonal   P8,n=n(3n-2)   1, 8, 21, 40, 65, ...

# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
# three interesting properties.
#
#    1. The set is cyclic, in that the last two digits of each number
#    is the first two digits of the next number (including the last
#    number with the first).
#
#    2. Each polygonal type: triangle (P3,127=8128), square
#    (P4,91=8281), and pentagonal (P5,44=2882), is represented by a
#    different number in the set.
#
#    3. This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers
# for which each polygonal type: triangle, square, pentagonal,
# hexagonal, heptagonal, and octagonal, is represented by a different
# number in the set.

from math import sqrt,floor

def tri_number(n):
    return n * (n + 1) / 2

def sq_number(n):
    return n*n

def pent_number(n):
    return n * (3 * n - 1) / 2

def hex_number(n):
    return n * (2 * n - 1)

def hept_number(n):
    return n * ( 5 * n - 3) / 2

def oct_number(n):
    return n * (3 * n - 2)

# return numbers1 that can link to any numbers in numbers2
# link is last two digits from numbers1 match first two digits
# from numbers2
def links_to(number1, number2):
    number1s = str(number1)
    number2s = str(number2)
    return number1s[2:] == number2s[0:2]
    
def expand_link(number1, possible_links):
    links = []
    for possible_link in possible_links:
        if links_to(number1,possible_link):
            links.append(possible_link)
    return links
    
# generate valid 4-digit numbers
valid_tri = range(45, 141)
tri_numbers = [tri_number(n) for n in valid_tri]
print "tri_numbers: ", tri_numbers

valid_sq = range(32,100)
sq_numbers = [sq_number(n) for n in valid_sq]
print "sq_numbers: ", sq_numbers

valid_pent = range(26,82)
pent_numbers = [pent_number(n) for n in valid_pent]
print "pent_numbers: ", pent_numbers

valid_hex = range(23,71)
hex_numbers = [hex_number(n) for n in valid_hex]
print "hex_numbers: ", hex_numbers

valid_hept = range(21,64)
hept_numbers = [hept_number(n) for n in valid_hept]
print "hept_numbers: ", hept_numbers

valid_oct = range(19,59)
oct_numbers = [oct_number(n) for n in valid_oct]
print "oct_numbers: ", oct_numbers
    
#partitions = [tri_numbers, sq_numbers, pent_numbers, hex_numbers, hept_numbers, oct_numbers, tri_numbers]
partitions = [tri_numbers, sq_numbers, pent_numbers, hex_numbers, hept_numbers, oct_numbers]
#partitions = [tri_numbers, sq_numbers, pent_numbers]

def build_chain_rec(num_part, partitions, chain):
    if len(partitions) == 0:
        for num in num_part:
            if links_to(num, chain[0]):
                chain.append(num)
                return True
        return False

    for i in xrange(0, len(partitions)):
        # search part is the next partition to search for next links
        search_part = partitions[i]

        for num in num_part:
            chain.append(num)

            search_links = expand_link(num, search_part)
            if len(search_links) > 0:
                rp1 = partitions[0:i]
                rp2 = partitions[i+1:]
                rest_part = rp1
                rest_part.extend(rp2)
                if build_chain_rec(search_links, rest_part, chain):
                    return True            
                chain.pop()
            else:
                chain.pop()

    return False

def build_chain(partitions):
    for i in xrange(0, len(partitions)):
        chain = []
    
        start_part = partitions[i]
        
        rp1 = partitions[0:i]
        rp2 = partitions[i+1:]
        rest_part = rp1
        rest_part.extend(rp2)

        build_chain_rec(start_part, rest_part, chain)

        if len(chain) > 0:
            return chain
    return None

chain = build_chain(partitions)
print "chain: ", chain
print "sum: ", sum(chain)
